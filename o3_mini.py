import cv2
import numpy as np
import matplotlib.pyplot as plt


def extract_outline_points(png_path, approx_epsilon=0.01):
    """
    Loads a PNG file, converts it to grayscale, thresholds it, and
    extracts the contour points representing the outline.

    Args:
        png_path (str): Path to the PNG file.
        approx_epsilon (float): Approximation accuracy as a percentage of arc length.

    Returns:
        outline (list): List of (x, y) tuples of the outline points.
    """
    # Load image in grayscale
    img = cv2.imread(png_path, cv2.IMREAD_GRAYSCALE)
    if img is None:
        raise FileNotFoundError(f"Could not load image at {png_path}")

    # Threshold the image to binary (depends on the PNG, adjust threshold if needed)
    ret, thresh = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY_INV)

    # Find contours; cv2.RETR_EXTERNAL to get outer contours
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    if len(contours) == 0:
        raise ValueError("No contours found in image")

    # Assume the largest contour is the outline we want (change if needed)
    contour = max(contours, key=cv2.contourArea)

    # Approximate the contour to reduce the number of points; epsilon is a percentage of arc length.
    epsilon = approx_epsilon * cv2.arcLength(contour, True)
    approx = cv2.approxPolyDP(contour, epsilon, True)

    # Convert array of points to a list of tuples (x, y)
    outline = [(int(pt[0][0]), int(pt[0][1])) for pt in approx]
    return outline


def generate_krl_script(points, output_file="draw_outline.src",
                        safe_offset=20.0, z_draw=50.0, tool_id=1, base_id=1):
    """
    Generates a KRL script that draws an outline based on the given points.

    Args:
        points (list): List of (x, y) tuples.
        output_file (str): Output filename for the generated KRL source file.
        safe_offset (float): Z offset (in mm) used for the safe approach/retract.
        z_draw (float): Z coordinate used during drawing.
        tool_id (int): Tool configuration ID.
        base_id (int): Base configuration ID.

    This function writes a file containing a KRL script.
    """
    # Convert image points to robot coordinates.
    # Here, as an example, the points are scaled and offset.
    # Adjust conversion based on your robot calibration.
    scale = 1.0  # set scale factor (e.g. mm per pixel)
    offset_x = 0.0  # set desired offset in mm for X
    offset_y = 0.0  # set desired offset in mm for Y

    # Create KRL position strings from points:
    positions = []
    for (x, y) in points:
        # Convert image coordinates to robot coordinates (simple example)
        rx = x * scale + offset_x
        ry = y * scale + offset_y
        # Use constant z during drawing, additional calculation can be added
        pos_str = f"{{X {rx:.1f}, Y {ry:.1f}, Z {z_draw:.1f}, A 0.0, B 0.0, C 0.0}}"
        positions.append(pos_str)

    # Start building the KRL script:
    krl_lines = [
        "&ACCESS RVP",
        "&REL 0",
        "DEF DRAW_OUTLINE( )",
        "  ; KRL program generated by Python",
        f"  ; Number of points: {len(positions)}",
        f"  DECL INT numPoints",
        f"  numPoints = {len(positions)}",
        f"  DECL E6POS outlinePoints[{len(positions)}]",
        "",
        "  ; Define the points based on extracted coordinates"
    ]
    for i, pos in enumerate(positions, start=1):
        krl_lines.append(f"  outlinePoints[{i}] = {pos}")

    krl_lines.extend([
        "",
        f"  ; Set tool and base data",
        f"  $TOOL = tooldata[{tool_id}]",
        f"  $BASE = base_data[{base_id}]",
        "",
        "  ; Safe approach to first point",
        "  DECL E6POS approachPoint",
        "  approachPoint = outlinePoints[1]",
        f"  approachPoint.Z = approachPoint.Z + {safe_offset:.1f}  ; raise by safe offset",
        "  PTP approachPoint C_P",
        "",
        "  ; Move to start point and lower the pen",
        "  PTP outlinePoints[1] C_P",
        "  SET_DO 1,1  ; Lower pen (activate digital output 1)",
        "",
        "  ; Draw the outline",
        "  FOR i = 2 TO numPoints",
        "    LIN outlinePoints[i] C_P",
        "  ENDFOR",
        "",
        "  ; Optionally close the loop",
        "  LIN outlinePoints[1] C_P",
        "",
        "  ; Raise pen",
        "  SET_DO 1,0",
        "",
        "  ; Retract safely",
        "  approachPoint = outlinePoints[1]",
        f"  approachPoint.Z = approachPoint.Z + {safe_offset:.1f}",
        "  PTP approachPoint C_P",
        "END"
    ])

    # Save to file:
    with open(output_file, "w") as f:
        f.write("\n".join(krl_lines))
    print(f"KRL script generated and saved to {output_file}")


def plot_extracted_path(points):
    """
    Plots the extracted outline path using matplotlib.

    Args:
        points (list): List of (x, y) tuples.
    """
    if not points:
        print("No points to plot.")
        return

    # Unzip to get x and y lists:
    x_values, y_values = zip(*points)

    # Append first point to the end to close the shape
    x_plot = list(x_values) + [x_values[0]]
    y_plot = list(y_values) + [y_values[0]]

    plt.figure(figsize=(6, 6))
    plt.plot(x_plot, y_plot, 'b-', marker='o', markersize=5)
    plt.title("Extracted Outline Path")
    plt.xlabel("X (pixels or mm)")
    plt.ylabel("Y (pixels or mm)")
    plt.axis('equal')
    plt.grid(True)
    plt.show()


# Example usage:
if __name__ == "__main__":
    png_file = "img.png"  # Replace with your PNG file path

    try:
        # Step 1: Extract points from the PNG file
        outline_points = extract_outline_points(png_file, approx_epsilon=0.0002)
        print("Extracted Points:", outline_points)

        # Step 2: Visualize the drawing path
        plot_extracted_path(outline_points)

        # Step 3: Generate a KRL script using the extracted points
        generate_krl_script(outline_points, output_file="draw_outline.src",
                            safe_offset=20.0, z_draw=50.0, tool_id=1, base_id=1)

    except Exception as e:
        print("An error occurred:", e)